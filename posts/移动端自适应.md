---
title: 移动端自适应
description: 移动端自适应
aside: false
date: 2023-03-07
tags:
  - 项目搭建
---

## 方案一 js 方式

```ts
// h5-rem.js
detectOrient();
window.onresize = function () {
  detectOrient();
};
// 判断横屏竖屏  相当于媒体查询
function detectOrient() {
  const width = document.documentElement.clientWidth; //视窗宽
  const height = document.documentElement.clientHeight; //视窗高
  // const width = window.screen.width //显示屏宽
  // const height = window.screen.height //显示屏高
  const deviceWidth = width < 320 ? 320 : width; // > 750 ? 750 : width
  const deviceHeight = height < 320 ? 320 : height; // > 750 ? 750 : width

  if (width <= height) {
    x;
    // 7.5 显示屏分辨率
    // 竖屏
    document.documentElement.style.fontSize = deviceWidth / 7.5 + "px";
  } else {
    // 横屏
    document.documentElement.style.fontSize = deviceHeight / 7.5 + "px";
  }
}
// 使用时候 直接在首页引入即可
// main.js
import "@/utils/h5-rem";
```

## 方案二 px2rem-loader

`px2rem-loader`
`lib-flexible`
一般而言，lib-flexible 并不独立出现，而是搭配 px2rem-loader 一起做适配方案，目的是自动将 css 中的 px 转换成 rem。以下为它在 vue 中的使用。

1. 安装 lib-flexible

```ts
npm install lib-flexible --save-dev
或者
yarn add lib-flexible --save-dev
```

2. 引入 lib-flexible 在 main.ts 中引入 lib-flexible

```ts
// px2rem 自适应
import "lib-flexible";
```

3. 安装 px2rem-loader

```ts
npm install px2rem-loader --save-dev
或者
yarn add px2rem-loader --save-dev
```

4. 配置 px2rem-loader

- vue-cli 2.x 这里就不介绍了 基本上不会遇到了
- vue-cli 3.x <br />

找到 vue.config.js 文件

```ts
module.exports = {
  css: {
    loaderOptions: {
      css: {},
      postcss: {
        plugins: [
          require("postcss-px2rem")({
            // 以设计稿750为例， 750 / 10 = 75
            remUnit: 75,
          }),
        ],
      },
    },
  },
};
```

5. 如果是大屏 打开./node_modules/lib-flexible/flexible.js，找到如下片段源码：

```ts
function refreshRem() {
  var width = docEl.getBoundingClientRect().width;
  if (width / dpr > 540) {
    width = 540 * dpr;
  }
  var rem = width / 10;
  docEl.style.fontSize = rem + "px";
  flexible.rem = win.rem = rem;
}
```

在上述源码中，进行修改。例如我要适配的大屏幕尺寸是基于 3840 的设计稿，而要求最小范围是 1980，最大为 5760，那么我们要修改的则变为：

```ts
function refreshRem() {
  var width = docEl.getBoundingClientRect().width;
  if (width / dpr < 1980) {
    width = 1980 * dpr;
  } else if (width / dpr > 5760) {
    width = 5760 * dpr;
  }
  var rem = width / 10;
  docEl.style.fontSize = rem + "px";
  flexible.rem = win.rem = rem;
}
```

`修改源码要注意当前的项目重新安装依赖包的之后 就要重新修改一次源码`

## 方案三 vw-layout

```ts
npm i vw-layout --save
或者
yarn add vw-layout --save
```

项目根目录新建.postcssrc.js

```ts
module.exports = {
  plugins: {
    "postcss-aspect-ratio-mini": {},
    "postcss-px-to-viewport": {
      viewportWidth: 750, // (Number) 视口的宽度
      viewportHeight: 1334, // (Number) 视口的高度
      unitPrecision: 3, // (Number) 单位精度
      viewportUnit: "vw", // (String) 单位
      selectorBlackList: [".ignore", ".hairlines"], // (Array) 忽略文件
      minPixelValue: 1, // (Number) 设置要替换的最小像素值。
      mediaQuery: false, // (Boolean) 允许在媒体查询中转换px。
    },
    "postcss-viewport-units": {},
  },
};
```

## 方案四 postcss-px-to-viewport

在之前我们用的是 rem 根据 HTML font-size 去做缩放<br />
现在有了更好用的 vw vh<br />
vw 视口的最大宽度，1vw 等于视口宽度的百分之一<br />
vh 视口的最大高度，1vh 等于视口高度的百分之一<br />

### 1. 安装依赖

```ts
npm install postcss-px-to-viewport -D
或者
yarn add postcss-px-to-viewport -D
```

### 2. 配置

因为 vite 中已经内联了 postcss，所以并不需要额外的创建 postcss.config.js 文件<br />
vite.config.ts

```ts
import { fileURLToPath, URL } from "url";

import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import vueJsx from "@vitejs/plugin-vue-jsx";
import postcsspxtoviewport from "postcss-px-to-viewport"; //插件
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue(), vueJsx()],
  css: {
    postcss: {
      plugins: [
        postcsspxtoviewport({
          unitToConvert: "px", // 要转化的单位
          viewportWidth: 750, // UI设计稿的宽度
          unitPrecision: 6, // 转换后的精度，即小数点位数
          propList: ["*"], // 指定转换的css属性的单位，*代表全部css属性的单位都进行转换
          viewportUnit: "vw", // 指定需要转换成的视窗单位，默认vw
          fontViewportUnit: "vw", // 指定字体需要转换成的视窗单位，默认vw
          selectorBlackList: ["ignore-"], // 指定不转换为视窗单位的类名，
          minPixelValue: 1, // 默认值1，小于或等于1px则不进行转换
          mediaQuery: true, // 是否在媒体查询的css代码中也进行转换，默认false
          replace: true, // 是否转换后直接更换属性值
          landscape: false, // 是否处理横屏情况
        }),
      ],
    },
  },
  resolve: {
    alias: {
      "@": fileURLToPath(new URL("./src", import.meta.url)),
    },
  },
});
```

#### 如果你用的 vite 是 ts 他这个插件并没有提供声明文件可以新建个 postcss-px-to-viewport.d.ts 文件，跟 vite.ts 同级

```ts
declare module "postcss-px-to-viewport" {
  type Options = {
    unitToConvert: "px" | "rem" | "cm" | "em";
    viewportWidth: number;
    viewportHeight: number; // not now used; TODO: need for different units and math for different properties
    unitPrecision: number;
    viewportUnit: string;
    fontViewportUnit: string; // vmin is more suitable.
    selectorBlackList: string[];
    propList: string[];
    minPixelValue: number;
    mediaQuery: boolean;
    replace: boolean;
    landscape: boolean;
    landscapeUnit: string;
    landscapeWidth: number;
  };

  export default function (options: Partial<Options>): any;
}
```

在 tsconfig.config.json 引入声明文件 postcss-px-to-viewport.d.ts

```ts
{
  "extends": "@vue/tsconfig/tsconfig.node.json",
  "include": ["vite.config.", "vitest.config.", "cypress.config.", "postcss-px-to-viewport.*"],
  "compilerOptions": {
    "composite": true,
    "types": ["node"]
  }
}
```
